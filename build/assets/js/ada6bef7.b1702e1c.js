"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4027],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),m=u(n),c=r,p=m["".concat(l,".").concat(c)]||m[c]||d[c]||o;return n?a.createElement(p,s(s({ref:t},h),{},{components:n})):a.createElement(p,s({ref:t},h))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var u=2;u<o;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8786:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const o={title:"WebAssembly Components and wasmCloud Actors: A Glimpse of the Future",image:"/img/wasm.png",date:new Date("2022-06-16T15:00:00.000Z"),author:"Taylor Thomas",author_profile:"https://twitter.com/_oftaylor",description:"Using the Component Model with wasmCloud Actors",categories:["wasm","webassembly","components"],draft:!1},s=void 0,i={permalink:"/blog/webassembly_components_and_wasmcloud_actors_a_glimpse_of_the_future",source:"@site/blog/webassembly_components_and_wasmcloud_actors_a_glimpse_of_the_future.md",title:"WebAssembly Components and wasmCloud Actors: A Glimpse of the Future",description:"Using the Component Model with wasmCloud Actors",date:"2022-06-16T15:00:00.000Z",formattedDate:"June 16, 2022",tags:[],readingTime:15.665,hasTruncateMarker:!0,authors:[{name:"Taylor Thomas"}],frontMatter:{title:"WebAssembly Components and wasmCloud Actors: A Glimpse of the Future",image:"/img/wasm.png",date:"2022-06-16T15:00:00.000Z",author:"Taylor Thomas",author_profile:"https://twitter.com/_oftaylor",description:"Using the Component Model with wasmCloud Actors",categories:["wasm","webassembly","components"],draft:!1},prevItem:{title:"Reflections on Three Years of wasmCloud",permalink:"/blog/wasmcloud_third_anniversary"},nextItem:{title:"Building Portable, Scalable Components with TinyGo and wasmCloud",permalink:"/blog/example_creating_webassembly_actor_in_go_with_tinygo"}},l={authorsImageUrls:[void 0]},u=[{value:"The Component Model",id:"the-component-model",level:2},{value:"A New Way to Build Actors",id:"a-new-way-to-build-actors",level:2},{value:"Old vs new",id:"old-vs-new",level:3},{value:"The detailed view",id:"the-detailed-view",level:3},{value:"The httpserver &quot;receiver&quot;",id:"the-httpserver-receiver",level:4},{value:"The Business Logic",id:"the-business-logic",level:4},{value:"The keyvalue &quot;sender&quot;",id:"the-keyvalue-sender",level:4},{value:"The host sender",id:"the-host-sender",level:4},{value:"Linking and running",id:"linking-and-running",level:4},{value:"What did we learn?",id:"what-did-we-learn",level:2},{value:"Benefits",id:"benefits",level:3},{value:"Rough edges",id:"rough-edges",level:3},{value:"Where do we go from here?",id:"where-do-we-go-from-here",level:2},{value:"Special Thanks",id:"special-thanks",level:2}],h={toc:u};function d(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"wasm",src:n(3303).Z,width:"650",height:"364"})),(0,r.kt)("p",null,"Today we thought we would give you a glimpse of the future of WebAssembly and wasmCloud. As\nwasmCloud maintainers, we've always had a goal to follow all standards in the WebAssembly community.\nHowever, our other goal has been to create a platform on which you could leverage the power of Wasm\nfor real projects. For the last few years, these two goals have been somewhat at odds with one\nanother due to the bleeding-edge nature of Wasm. We've had to bridge the gap between Wasm's current\nstate and the requirements needed to do Something Real\u2122 with it. This is starting to change!"),(0,r.kt)("h2",{id:"the-component-model"},"The Component Model"),(0,r.kt)("p",null,"In the past year, the standards around Wasm and WASI have started to solidify and become reality.\nOne of the most interesting emerging standards has been the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WebAssembly/component-model"},"Component\nModel"),". The TL;DR of the component model is that you\nare able to glue together arbitrary Wasm modules that import or export functions, as specified by an\ninterface file. These interface files are called ",(0,r.kt)("inlineCode",{parentName:"p"},"wit")," files (Wasm Interface Types) and allow for\nlanguage agnostic code generation. This code is what handles converting the raw numbers of plain\nWasm (i.e. integers and bytes) into concrete types. If you are familiar with wasmCloud already, this\nis ",(0,r.kt)("a",{parentName:"p",href:"https://wasmcloud.dev/interfaces/"},"very similar")," to what we call \"contract driven development,\"\nwhich we use to separate non-functional requirements from business logic. Still confused? Don't\nworry, we'll be using some specific examples below. If this topic interests you and you'd like more\ninformation, we highly recommend you check out all of the\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WebAssembly/component-model/tree/main/design"},"documentation")," and\n",(0,r.kt)("a",{parentName:"p",href:"https://radu-matei.com/blog/intro-wasm-components/"},"examples")," that are available for the component\nmodel."),(0,r.kt)("h2",{id:"a-new-way-to-build-actors"},"A New Way to Build Actors"),(0,r.kt)("p",null,"So at this point, you are probably wondering \"What does this have to do with wasmCloud? Don't you\nalready have your own contract stuff and RPC protocol?\" Good question! Let's dive into this."),(0,r.kt)("p",null,"We recently created a proof of concept that shows our ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/wasmCloud/examples/blob/557770a1d1d763aab76583af9f57e2a4e2aa4e3a/actor/kvcounter/README.md"},"kvcounter\nexample"),"\nusing the Component Model to provide all the necessary logic that used to be provided by our\n",(0,r.kt)("inlineCode",{parentName:"p"},"wasmbus-rpc")," Rust crate and other language specific libraries. Please note that this is not a fully\nfunctional example that can run in wasmCloud currently; it's meant to show how we can glue together\nvarious components, call the actor from the host, and then have the actor send data back to the\nhost. We'll break down all the different parts of this example below, but you can find the actual\nsource code ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/wasmCloud/examples/tree/spike/wit-interfaces/actor/kvcounter"},"here"),"."),(0,r.kt)("h3",{id:"old-vs-new"},"Old vs new"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"components-diagram",src:n(7794).Z,width:"1737",height:"1098"})),(0,r.kt)("p",null,"As you can see in the diagram above, there was a lot of stuff that had to be done inside of\nlanguage-specific and user-managed code. In fact, we just finished writing all of this code for Go\nas well, and it was a heavy lift! In the future version, things become significantly more modular.\nThe communication to the host (which then gets sent over our RPC layer, ",(0,r.kt)("a",{parentName:"p",href:"https://wasmcloud.dev/reference/lattice/"},"the\nlattice"),") is handled by one module, and then we just\nprovide a single Wasm module that satisfies each interface. This highlights why we are excited about\nWasm. Wasm is language agnostic, which means that instead of having to create special ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmbus-rpc"),"\nlibraries for every single language we want to support, and then generating code for every\ninterface, we can now write a single module in whatever language we want. Then, we can use that\nmodule to provide the necessary code to a wasmCloud actor written ",(0,r.kt)("em",{parentName:"p"},"in any other language"),". If that\ndoesn't make you excited, we don't know what will."),(0,r.kt)("h3",{id:"the-detailed-view"},"The detailed view"),(0,r.kt)("p",null,"From here on out, we are going to go into the specifics of how everything works. This will likely be\nuseful to anyone wanting to experiment with the component model or who wants to better understand\nhow it works. If that doesn't interest you, please feel free to skip down to the ",(0,r.kt)("a",{parentName:"p",href:"#what-did-we-learn"},'"What did we\nlearn?" section')),(0,r.kt)("p",null,"We're going to go from the top to the bottom as represented in the diagram above to explain what\neach component does, so please go back and reference it if anything below is confusing. Then we'll\nexplain how we linked and ran the example."),(0,r.kt)("h4",{id:"the-httpserver-receiver"},'The httpserver "receiver"'),(0,r.kt)("p",null,"Under the new paradigm, each wasmCloud interface will need to have two different WebAssembly\nmodules: a sender and a receiver. The receiver half is used when the actor needs to receive a\nmessage from the host it is running on (hence the name). In wasmCloud, this means the host will\nreceive a message on ",(0,r.kt)("a",{parentName:"p",href:"https://wasmcloud.dev/reference/lattice/"},"the lattice")," and then invoke the\n",(0,r.kt)("inlineCode",{parentName:"p"},"receive")," method of the actor. This first module of the proof of concept is the httpserver contract\nreceiver. In order to implement this, the module needs to import one interface and export another.\nHere are what the interfaces look like:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"wasmbus_receiver.wit")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plain"},"// These are importing some common types that you see in the receive function signature. See the\n// actual code on Github if you are curious what these types look like\nuse * from error-type\nuse * from wasmbus-common\n\nreceive: function(msg: message) -> expected<payload, rpc-error>\n")),(0,r.kt)("p",null,"You'll see that this interface has single function, the ",(0,r.kt)("inlineCode",{parentName:"p"},"receive")," function that allows an actor to\nreceive a message. We'll see how this works in code below"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"httpserver.wit")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plain"},"use * from error-type\n\ntype header-map = list<tuple<string, string>>\n\nrecord http-request {\n    // HTTP method. One of: GET,POST,PUT,DELETE,HEAD,OPTIONS,CONNECT,PATCH,TRACE\n    method: string,\n    // full request path\n    path: string,\n    // query string. May be an empty string if there were no query parameters.\n    query-string: string,\n    // map of request headers (string key, string value)\n    header: header-map,\n    body: list<u8>,\n}\n\nrecord http-response {\n    // statusCode is a three-digit number, usually in the range 100-599 a value of 200 indicates success.\n    status-code: u16,\n    // Map of headers (string keys, list of values)\n    header: header-map,\n    // Body of response as a byte array. May be an empty array.\n    body: list<u8>,\n}\n\nhandle-request: function(req: http-request) -> expected<http-response, rpc-error>\n")),(0,r.kt)("p",null,"The httpserver receiver has to export the ",(0,r.kt)("inlineCode",{parentName:"p"},"receive")," method and implement the logic to parse that\nmessage as an HTTP request. Basically, it acts as a translation layer between the RPC layer and the\nactual contract it needs to call. The code for it is actually quite straightforward (and is\nannotated with comments below). Our code was written in Rust, but you could write it in any language\nthat has ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bytecodealliance/wit-bindgen/"},"wit-bindgen")," support"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use wasmbus_receiver::*;\n\n// Import the httpserver contract so we can call it\nwit_bindgen_rust::import!("../httpserver.wit");\n// Export our implementation of the `receive` method\nwit_bindgen_rust::export!("../wasmbus-receiver.wit");\n\nconst HANDLE_REQUEST_METHOD: &str = "HttpServer.HandleRequest";\n\n// Some custom types for massaging data are elided here\n\n#[derive(Default, Clone)]\npub struct WasmbusReceiver;\n\nimpl wasmbus_receiver::WasmbusReceiver for WasmbusReceiver {\n    fn receive(msg: Message) -> Result<Payload, RpcError> {\n        if msg.method != HANDLE_REQUEST_METHOD {\n            return Err(RpcError::MethodNotHandled(format!(\n                "Method {} is not supported by the httpserver contract",\n                msg.method\n            )));\n        }\n        // Parse the message body into an http request\n        let req: HttpRequestInternal = serde_json::from_slice(&msg.arg)\n            .map_err(|e| RpcError::Deser(format!("httpserver: {}", e)))?;\n        // Data massaging\n        let header: Vec<(&str, &str)> = req\n            .header\n            .iter()\n            .map(|(k, v)| (k.as_str(), v.as_str()))\n            .collect();\n\n        // Call the `handle_request` method that will be provided by another module\n        let resp: HttpResponseInternal = httpserver::handle_request(httpserver::HttpRequest {\n            method: &req.method,\n            path: &req.path,\n            query_string: &req.query_string,\n            header: &header,\n            body: &req.body,\n        })\n        .map_err(httpserver_to_wasmbus_error)?\n        .into();\n        serde_json::to_vec(&resp).map_err(|e| RpcError::Ser(e.to_string()))\n    }\n}\n')),(0,r.kt)("h4",{id:"the-business-logic"},"The Business Logic"),(0,r.kt)("p",null,"This module is the actual part that contains the business logic that someone would be writing. This\nis the only user-provided code for someone writing their business logic to run on wasmCloud. All of\nthe other modules described in this section would be provided by the interface writer or by\nwasmCloud directly."),(0,r.kt)("p",null,"This code also requires the use of two interfaces: httpserver (see the previous section) and\nkeyvalue:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"keyvalue.wit")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plain"},"use * from error-type\n\n// Increment the value of the key by the given amount\nincrement: function(key: string, value: s32) -> expected<s32, rpc-error>\n")),(0,r.kt)("p",null,"Please note that this is a stripped-down version of what the actual keyvalue contract would look\nlike, to keep things simple. Now, we can move on to the actual code (annotated):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use httpserver::*;\n\n// Import the keyvalue contract so we can call it\nwit_bindgen_rust::import!("../keyvalue.wit");\n\n// Export our implementation of the httpserver contract\nwit_bindgen_rust::export!("../httpserver.wit");\n\n#[derive(Default, Clone)]\npub struct Httpserver;\n\nimpl httpserver::Httpserver for Httpserver {\n    fn handle_request(req: HttpRequest) -> Result<HttpResponse, RpcError> {\n        // make friendlier key\n        let key = format!("counter:{}", req.path.replace(\'/\', ":"));\n\n        // bonus: use specified amount from query, or 1\n        let amount: i32 = form_urlencoded::parse(req.query_string.as_bytes())\n            .find(|(n, _)| n == "amount")\n            .map(|(_, v)| v.parse::<i32>())\n            .unwrap_or(Ok(1))\n            .unwrap_or(1);\n\n        // increment the value in kv and send response in json\n        let (body, status_code) = match increment_counter(key, amount) {\n            Ok(v) => (serde_json::json!({ "counter": v }).to_string(), 200),\n            // if we caught an error, return it to client\n            Err(e) => (\n                serde_json::json!({ "error": format!("{:?}", e) }).to_string(),\n                500,\n            ),\n        };\n        let resp = HttpResponse {\n            body: body.as_bytes().to_vec(),\n            status_code,\n            header: Vec::new(),\n        };\n        Ok(resp)\n    }\n}\n\nfn increment_counter(key: String, value: i32) -> Result<i32, RpcError> {\n    // Call the `increment` function that will be provided by another module\n    keyvalue::increment(&key, value).map_err(map_wit_err)\n}\n')),(0,r.kt)("p",null,"You'll see that this code looks almost identical to the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/wasmCloud/examples/blob/557770a1d1d763aab76583af9f57e2a4e2aa4e3a/actor/kvcounter/src/lib.rs#L1"},"original kvcounter\nactor"),",\nexcept that there is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"zero wasmCloud-specific code needed")),"!"),(0,r.kt)("h4",{id:"the-keyvalue-sender"},'The keyvalue "sender"'),(0,r.kt)("p",null,"As we mentioned above, there are two halves needed for each contract. This component exports the\nkeyvalue contract described above and also requires one other interface:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"wasmbus-sender.wit")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plain"},"use * from error-type\nuse * from wasmbus-common\n\nsend: function(msg: message, contract-name: string, link-name: option<string>) -> expected<payload, rpc-error>\n")),(0,r.kt)("p",null,"As you can see, this has a single function called ",(0,r.kt)("inlineCode",{parentName:"p"},"send")," that is used to send a message through the\nlattice. This does the exact reverse of the receiver, in that it takes a concrete type and turns it\ninto a generic message that can be sent. The annotated code is below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use keyvalue::*;\nuse wasmbus_sender as wasmbus;\n\n// Export our implementation of the keyvalue contract\nwit_bindgen_rust::export!("../keyvalue.wit");\n// Import the sender contract for us to call\nwit_bindgen_rust::import!("../wasmbus-sender.wit");\n\n// Custom request type elided\n\n#[derive(Default, Clone)]\npub struct Keyvalue;\n\nimpl keyvalue::Keyvalue for Keyvalue {\n    fn increment(key: String, value: i32) -> Result<i32, RpcError> {\n        // Encode the data as our payload\n        let payload = serde_json::to_vec(&IncrementRequest { key, value })\n            .map_err(|e| RpcError::Ser(e.to_string()))?;\n\n        // Call the `send` method provided by another module\n        // NOTE: this code is not dealing with the link name yet just to keep it simple\n        // We will figure out how we want this to work when implementing\n        let resp = wasmbus::send(\n            wasmbus::Message {\n                method: "KeyValue.Increment",\n                arg: &payload,\n            },\n            "wasmcloud:keyvalue",\n            None,\n        )\n        .map_err(wasmbus_to_keyvalue_error)?;\n        serde_json::from_slice(&resp).map_err(|e| RpcError::Deser(e.to_string()))\n    }\n}\n')),(0,r.kt)("h4",{id:"the-host-sender"},"The host sender"),(0,r.kt)("p",null,"Last, but not least, is the module that can send a message back to a host (so the host can send it\non the lattice). For our purposes here, this just prints to stdout (which means we are using a\nfunction from the host just like we would for real), but when we do it for realsies, this will be\ncalling a specific function the host will provide for us. This module only requires the\n",(0,r.kt)("inlineCode",{parentName:"p"},"wasmbus-sender.wit")," contract shown in the previous section. As for the code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use wasmbus_sender::*;\n\n// Export our implementation for the `send` method\nwit_bindgen_rust::export!("../wasmbus-sender.wit");\n\n#[derive(Default, Clone)]\npub struct WasmbusSender;\n\nimpl wasmbus_sender::WasmbusSender for WasmbusSender {\n    fn send(\n        msg: Message,\n        contract_name: String,\n        link_name: Option<String>,\n    ) -> Result<Payload, RpcError> {\n        // Fake a host call (fd_write in this case)\n        println!(\n            "Linkname: {}, contract_name: {}, msg: {:#?}",\n            link_name.unwrap_or_else(|| "default".to_string()),\n            contract_name,\n            msg\n        );\n        // Return the answer to everything\n        Ok(serde_json::to_vec(&42).unwrap())\n    }\n}\n')),(0,r.kt)("h4",{id:"linking-and-running"},"Linking and running"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"NOTE"),": Right as we were preparing this blog post, the ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmlink")," command and tooling\nwas ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bytecodealliance/wit-bindgen/pull/240"},"removed")," from the wit-bindgen repo in\nfavor of the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bytecodealliance/wit-bindgen/pull/239"},"most up to date component model\ncode"),". This new component model tooling is\ngoing to be the future, but currently, there isn't really a replacement for ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmlink"),". So the\nsection below is slightly out of date, but still shows that all of this will work with the new\ntooling in the future. As we actually implement this, we will release a new blog post that shows how\nthe new tooling works")),(0,r.kt)("p",null,"For our proof of concept, we used the ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmlink")," command. When we do this for real, we will use the\nunderlying Rust linker library that ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmlink")," uses. To be honest, this tool is a little confusing\nto use, so hopefully we can enlighten you here. Before linking, we built all of the modules in the\nworkspace by running ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo build --release"),". Once they were built, we ran the following command to\nlink them together"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-terminal"},"wasmlink ./target/wasm32-wasi/release/httpserver.wasm \\\n   -m keyvalue=./target/wasm32-wasi/release/keyvalue.wasm \\\n   -m httpserver=./target/wasm32-wasi/release/kvcounter_actor.wasm \\\n   -m wasmbus-sender=./target/wasm32-wasi/release/wasmbus_sender.wasm \\\n   -i wasmbus-sender=wasmbus-sender.wit \\\n   -i keyvalue=keyvalue.wit \\\n   -i httpserver=httpserver.wit \\\n   -i receiver=wasmbus-receiver.wit \\\n   -p wasmtime \\\n   -o compiled.wasm\n")),(0,r.kt)("p",null,"Ok, so that is a pretty gnarly command. Let's break it down:"),(0,r.kt)("p",null,"First off is the module name (",(0,r.kt)("inlineCode",{parentName:"p"},"./target/wasm32-wasi/release/httpserver.wasm"),"). There is one very\nimportant detail here. This module should be the one you want to call (the one with the ",(0,r.kt)("inlineCode",{parentName:"p"},"receive"),"\nfunction), otherwise the export gets mangled and no longer shows up in the compiled file."),(0,r.kt)("p",null,"All of the ",(0,r.kt)("inlineCode",{parentName:"p"},"-m")," flags specify the other modules to link in. They are specified in the form of\n",(0,r.kt)("inlineCode",{parentName:"p"},"MODULE_NAME=MODULE_PATH"),". The module name must match the name of the interface it is exporting.\nThose interfaces are specified with the ",(0,r.kt)("inlineCode",{parentName:"p"},"-i")," flag with the form ",(0,r.kt)("inlineCode",{parentName:"p"},"MODULE_NAME=WIT_PATH"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"-o"),"\nflag specifies the output path where the compiled module is written to."),(0,r.kt)("p",null,"Oh, and that ",(0,r.kt)("inlineCode",{parentName:"p"},"-p")," flag? Pretty sure it doesn't matter based on what we found in the code, but it is\na required flag. It does look like it may matter in the future though."),(0,r.kt)("p",null,"Whew...that was hard. Onward to the cool part \u2013 actually running the thing. We did this in code as\nit was needed to actually call everything properly. Let's look at the whole code sample (annotated):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use wasmtime::{Config, Engine, Linker, Module, Store};\nuse wasmtime_wasi::WasiCtx;\n\n// Import the wasmbus-receiver contract with the wasmtime helpers (note that this is a different\n// crate than what we used above)\nwit_bindgen_wasmtime::import!(\n    "/Users/oftaylor/Documents/code/examples/actor/kvcounter/wasmbus-receiver.wit"\n);\n\n// Elided an http request type here\n\n// A custom struct for storing data in the wasmtime engine\nstruct StoreData {\n    wasi: WasiCtx,\n    receiver: wasmbus_receiver::WasmbusReceiverData,\n}\n\nfn main() {\n    let mut config = Config::default();\n    // Enable the experimental module linking and multimemory proposals. These are required to make things work\n    config.wasm_module_linking(true);\n    config.wasm_multi_memory(true);\n    let engine = Engine::new(&config).unwrap();\n\n    let mut linker: Linker<StoreData> = Linker::new(&engine);\n    // Add all the wasi stuff to the linker\n    wasmtime_wasi::add_to_linker(&mut linker, |ctx| &mut ctx.wasi)\n        .expect("Unable to add to wasi things to linker");\n\n    let wasi = wasmtime_wasi::WasiCtxBuilder::new()\n        .inherit_stdio()\n        .inherit_args()\n        .expect("Unable to inherit args")\n        .build();\n\n    let mut store = Store::new(\n        &engine,\n        StoreData {\n            wasi,\n            receiver: wasmbus_receiver::WasmbusReceiverData {},\n        },\n    );\n\n    // Load the compiled wasm module we built above\n    let receiver_module = Module::from_file(\n        &engine,\n        "/code/examples/actor/kvcounter/compiled.wasm",\n    )\n    .unwrap();\n\n    // Use the instantiate helper from wit-bindgen\n    let (server, _instance) = wasmbus_receiver::WasmbusReceiver::instantiate(\n        &mut store,\n        &receiver_module,\n        &mut linker,\n        |ctx| &mut ctx.receiver,\n    )\n    .unwrap();\n\n    let req = HttpRequestInternal {\n        method: "GET",\n        path: "/",\n        query_string: "",\n        header: vec![("HOST", "foobar")],\n        body: &[],\n    };\n    // Call the receive method exported by our module\n    let resp = server\n        .receive(\n            &mut store,\n            wasmbus_receiver::Message {\n                method: "HttpServer.HandleRequest",\n                arg: &serde_json::to_vec(&req).expect("Should serialize"),\n            },\n        )\n        .expect("Shouldn\'t get a trap")\n        .expect("Unable to send to actor");\n\n    println!("body: {}", String::from_utf8_lossy(&resp));\n}\n')),(0,r.kt)("p",null,"When we ran this, we could see the output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Linkname: default, contract_name: wasmcloud:keyvalue, msg: Message {\n    method: "KeyValue.Increment",\n    arg: [\n        123,\n        34,\n        107,\n        101,\n        ...\n    ],\n}\nbody: {"status_code":200,"header":[],"body":[123,34,99,111,117,110,116,101,114,34,58,52,50,125]}\n')),(0,r.kt)("p",null,"This means we got all the way down to the ",(0,r.kt)("inlineCode",{parentName:"p"},"send")," method and returned data all the way up the stack\nas the expected HTTP response!"),(0,r.kt)("h2",{id:"what-did-we-learn"},"What did we learn?"),(0,r.kt)("h3",{id:"benefits"},"Benefits"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We won't need to use our bespoke Smithy + code generation any more"),(0,r.kt)("li",{parentName:"ul"},"No more bespoke wasmbus libraries per language. Modules can even be loaded by providers to\nproperly translate a message from the lattice"),(0,r.kt)("li",{parentName:"ul"},"No wasmCloud-specific code when you write your actors. In fact, if our contract is the same as\nthose used by other platforms, they could even be interchangeable!"),(0,r.kt)("li",{parentName:"ul"},"Easily pluggable and patchable wasmCloud specific code. If there is a bug fix we have to the\nunderlying RPC protocol, we can hot patch all running actors with no user interaction")),(0,r.kt)("h3",{id:"rough-edges"},"Rough edges"),(0,r.kt)("p",null,"To be clear, it isn't all sunshine and rainbows yet. These are a few of the rough edges we\nencountered and how they impacted us"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"No dynamic linking yet. This means we have to manually pull everything down and link it before\nwe can run it. Not ideal, but we are able to do it through code."),(0,r.kt)("li",{parentName:"ul"},"Linking everything means you must include both the module and the interface file when\ndistributing things, which means you have to build tooling around building things like\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/deislabs/bindle"},"bindles")),(0,r.kt)("li",{parentName:"ul"},"Even when you have reused types (like our ",(0,r.kt)("inlineCode",{parentName:"li"},"rpc-error")," above in the wit files), each interface\ntechnically has a different type in strongly-typed languages. This requires conversion between\nthe identical types imported from different interfaces. Obviously things like Rust macros can be\nuse to make this a little less clunky, but it is a bit of a chore")),(0,r.kt)("h2",{id:"where-do-we-go-from-here"},"Where do we go from here?"),(0,r.kt)("p",null,"Now we move into the future. To be absolutely clear, YOU CANNOT yet do this inside of wasmCloud, but\nthis proof of concept proved that we can use the component model to greatly improve the experience\nof writing actors in wasmCloud ",(0,r.kt)("em",{parentName:"p"},"and")," achieve our goal of being in line with community standards. In\norder to make this all work, it will take a major refactor of the underlying code we use to run\nactors as well as some refactors to our RPC layer. This will obviously be a breaking change so we\nwill need to clearly communicate when the work is going to land so as to not disturb too many of our\ncurrent users."),(0,r.kt)("p",null,"We will also need to rely more heavily on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/deislabs/bindle"},"Bindle")," and\neventually on the forthcoming component registry work from the Bytecode Alliance. These tools are\ndesigned specifically to account for assembling various parts of a final application (like the\nvarious interfaces and different modules). We already have ",(0,r.kt)("a",{parentName:"p",href:"https://wasmcloud.dev/reference/bindle/"},"experimental support for\nbindles")," in wasmCloud, but they have to be hand rolled\nrather than being automatically created. There also needs to be a place from which you can fetch the\nnecessary interfaces for use in building. All of these elements of developer experience are\nimportant to have before we roll this out."),(0,r.kt)("p",null,"So, stay tuned! We are planning on a follow up blog post to this one once we actually roll out the\nsupport in wasmCloud"),(0,r.kt)("h2",{id:"special-thanks"},"Special Thanks"),(0,r.kt)("p",null,"We wanted to give a shout out and thanks to ",(0,r.kt)("a",{parentName:"p",href:"https://radu-matei.com/"},"Radu Matei")," for his help as we\nfigured out some of the intricacies of the component model, as well as his previous work and blog\nposts in this area. That work gave us a great starting place for what we are building here."))}d.isMDXComponent=!0},7794:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/components_diagram-1d5903bd10cc0a5ec658663a1b4c596f.png"},3303:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/wasm-646a4d97ae9e2335b37989568d48a04f.png"}}]);