"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4088],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>f});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=c(a),f=i,d=m["".concat(l,".").concat(f)]||m[f]||p[f]||r;return a?n.createElement(d,o(o({ref:t},u),{},{components:a})):n.createElement(d,o({ref:t},u))}));function f(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},299:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));const r={title:"wasmCloud Capabilities are Managed Algebraic Effects for WebAssembly Functions",image:"/img/algebra.jpg",date:new Date("2022-05-25T13:00:00.000Z"),author:"Kevin Hoffman",author_profile:"https://www.linkedin.com/in/%F0%9F%A6%80-kevin-hoffman-9252669/",description:"wasmCloud Capabilities are a managed, distributed implementation of algebraic effects",categories:["webassembly","wasmcloud"],draft:!1},o=void 0,s={permalink:"/blog/caps_are_effects",source:"@site/blog/caps_are_effects.md",title:"wasmCloud Capabilities are Managed Algebraic Effects for WebAssembly Functions",description:"wasmCloud Capabilities are a managed, distributed implementation of algebraic effects",date:"2022-05-25T13:00:00.000Z",formattedDate:"May 25, 2022",tags:[],readingTime:4.2,hasTruncateMarker:!0,authors:[{name:"Kevin Hoffman"}],frontMatter:{title:"wasmCloud Capabilities are Managed Algebraic Effects for WebAssembly Functions",image:"/img/algebra.jpg",date:"2022-05-25T13:00:00.000Z",author:"Kevin Hoffman",author_profile:"https://www.linkedin.com/in/%F0%9F%A6%80-kevin-hoffman-9252669/",description:"wasmCloud Capabilities are a managed, distributed implementation of algebraic effects",categories:["webassembly","wasmcloud"],draft:!1},prevItem:{title:"Building Portable, Scalable Components with TinyGo and wasmCloud",permalink:"/blog/example_creating_webassembly_actor_in_go_with_tinygo"},nextItem:{title:"Deploying wasmCloud Actors from Github Packages",permalink:"/blog/2022-05-23_ghcr-actions"}},l={authorsImageUrls:[void 0]},c=[],u={toc:c};function p(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"algebra",src:a(8322).Z,width:"393",height:"271"})),(0,i.kt)("p",null,"We spend a lot of time talking about how the wasmCloud capability provider system, from its abstract contracts to the ability to hot-swap providers, is a way to separate non-functional requirements from business logic code. While all of that is true, it's also a fairly ",(0,i.kt)("em",{parentName:"p"},"enterprisey")," way to describe it. In this blog post, I'll describe them another way using terms from functional programming."),(0,i.kt)("p",null,"Let's take a look at a simple function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"f(x) = x + 12\n")),(0,i.kt)("p",null,"This function is ",(0,i.kt)("em",{parentName:"p"},'"pure"'),". For every input of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," there is only one output. In math terms that makes it a proper function, but in programming terms that means it's deterministic, and determinism means we can write unit tests for it. We could write a test that ensures that when I supply a ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," to this function, it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"14"),"."),(0,i.kt)("p",null,'Unfortunately, the second we expand our code beyond the realm of "hello world", it becomes more and more difficult to maintain purity. Our code needs to interact with the world, and it often does so in messy, unpredictable ways. Even if it isn\'t messy, we frequently see functions where the answer is only predictable for a short period of time.'),(0,i.kt)("p",null,"Let's take a look at this (psuedocode) function from a hypothetical bank back-end that handles an international withdrawal from a customer's account:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"internationalWithdrawal account amount localCurrency =\n    exchangeRate = Market.getRate(localCurrency)\n    newAmount = amount * exchangeRate\n    fee = Market.getFee(localCurrency)\n    Ledger.withdraw(account, amount, newAmount, exchangeRate)\n    Ledger.fee(account, fee)\n    Ledger.balance(account)\n")),(0,i.kt)("p",null,'This function reaches out to "the market" to get the currency exchange rate between the canonical currency and the local currency. Then it reaches out to get the current fee for international withdrawals. Finally, it consumes a ledger to perform the withdrawal, take away the international transaction fee, and finally return the current/updated balance.'),(0,i.kt)("p",null,"There's nothing pure about this function, but it's an ",(0,i.kt)("em",{parentName:"p"},"extremely")," common idiom. This function relies on two external interactions, a ",(0,i.kt)("inlineCode",{parentName:"p"},"Market")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"Ledger"),". The exchange rate is something that fluctuates constantly throughout the day, and the ledger presumably gives the function access to the account ledger for a specific account."),(0,i.kt)("p",null,"This function is non-deterministic because it has a number of ",(0,i.kt)("em",{parentName:"p"},"algebraic effects"),'. Such effects are a category for the messy, "impure" things that happen in our functions. For most of us, we probably write more impure functions than not.'),(0,i.kt)("p",null,'I\'ve already tried to make this function fairly clean and simple. In contrast, I\'ve seen functions like this turned into "kitchen sinks" where a single function establishes a connection to two different databases and issues queries directly to them. We fool ourselves into thinking the function is pure by hiding the tight coupling a few layers down in the library, but this is still tight coupling at its worst. In cases like this, you can\'t test this function without live access to real databases, and after that you have to figure out how to make your tests deterministic (which often involves "test databases").'),(0,i.kt)("p",null,"A lot of us are used to patterns like (micro)services, abstractions, anti-corruption layers, and more all designed to help us mitigate the ugly side effects this function has. But what if we could embrace these effects and write functions that are explicit about their effect needs, ",(0,i.kt)("em",{parentName:"p"},"without")," losing testability, flexibility, and purity?"),(0,i.kt)("p",null,'In a traditional object-oriented language or framework, we might treat each of these "effect providers" as an interface and then use something like dependency injection to shunt in an implementation for the effect at runtime (and presumably shunt in a mock during test time).'),(0,i.kt)("p",null,"In wasmCloud, we manage algebraic effects through ",(0,i.kt)("u",null,(0,i.kt)("a",{parentName:"p",href:"https://wasmcloud.dev/reference/host-runtime/capabilities/"},"capability providers")),". Here the capability provider, as seen by the WebAssembly module (",(0,i.kt)("u",null,(0,i.kt)("a",{parentName:"p",href:"https://wasmcloud.dev/reference/host-runtime/actors/"},"actor")),"), is just an abstraction. It's a versioned contract through which the WebAssembly function gets its effects."),(0,i.kt)("p",null,'The host runtime is responsible for providing an implementation for those effects or effect providers. This implementation is hot-swappable and dynamically configurable. This means that in our preceding international withdrawal example, we could provide a "test market" at unit test time and then a real connection to the market service when running in production. We could also configure the market connection so it could be "real", but point to a different service in staging than in production.'),(0,i.kt)("p",null,'Algebraic effects don\'t need to be big, high-level concepts like database or networking clients. Even something as basic as logging is an effect (because all I/O is "effectful"). So we might use yet another provider like this:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},'Logger.debug("Performing international withdrawal")\n')),(0,i.kt)("p",null,"wasmCloud takes these algebraic effects even further by requiring each of our WebAssembly modules to be ",(0,i.kt)("u",null,(0,i.kt)("a",{parentName:"p",href:"https://wasmcloud.dev/reference/host-runtime/security/"},"cryptographically signed"))," with the explicit list of capabilities it can use (effects it can produce)."),(0,i.kt)("p",null,"Ultimately what we've done is provided a means to maintain portable function purity in WebAssembly modules while allowing for all algebraic effects to not only be testable, but distributed, hot-swappable, and dynamically scalable across a flat topology system comprised of multiple disparate environments."),(0,i.kt)("p",null,"If you're interested in learning more about capabilities and seeing them in action, take a look at our ",(0,i.kt)("u",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/wasmcloud/examples/"},"examples"))," repository."))}p.isMDXComponent=!0},8322:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/algebra-1e4d52757c617c6be9a0f5ac7a3c3806.jpg"}}]);